import os
import sys
import asyncio
import tkinter as tk
import threading
from app import BrowserAutomationApp
from browser_automation import BrowserAutomation

# 創建一個全局的執行器，用於處理所有的異步操作
class AsyncExecutor:
    def __init__(self):
        self.loop = None
        self.thread = None
        self.running = False
        self.automation = None
    
    def start(self):
        """啟動執行器"""
        if self.running:
            return
        
        self.running = True
        self.thread = threading.Thread(target=self._run_event_loop, daemon=True)
        self.thread.start()
    
    def _run_event_loop(self):
        """運行事件循環"""
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        
        try:
            self.loop.run_forever()
        finally:
            self.loop.close()
            self.loop = None
    
    def stop(self):
        """停止執行器"""
        if not self.running:
            return
        
        if self.loop:
            self.loop.call_soon_threadsafe(self.loop.stop)
        
        self.running = False
        if self.thread and self.thread.is_alive():
            self.thread.join(timeout=1)
    
    def run_task(self, coroutine):
        """執行異步任務
        
        Args:
            coroutine: 要執行的協程
        
        Returns:
            返回Future對象
        """
        if not self.running or not self.loop:
            return None
        
        future = asyncio.run_coroutine_threadsafe(coroutine, self.loop)
        return future

# 全局執行器
executor = AsyncExecutor()

def main():
    """主程序入口點"""
    # 啟動異步執行器
    executor.start()
    
    # 確保資源目錄存在
    os.makedirs("assets", exist_ok=True)
    
    # 創建GUI
    root = tk.Tk()
    app = BrowserAutomationApp(root)
    
    # 替換錄製相關函數
    async def start_recording_async():
        """開始錄製的異步方法"""
        try:
            if executor.automation:
                # 如果已經有一個瀏覽器實例，嘗試關閉它
                try:
                    await executor.automation.close_browser()
                except Exception:
                    pass
            
            # 創建新的自動化實例
            executor.automation = BrowserAutomation(
                callback=lambda progress, msg: app.root.after(0, lambda: app.status_var.set(msg))
            )
            await executor.automation.start_recording()
        except Exception as e:
            app.status_var.set(f"錄製啟動失敗: {e}")
    
    def start_recording():
        """啟動錄製"""
        app.status_var.set("正在啟動錄製...")
        executor.run_task(start_recording_async())
    
    async def pause_recording_async():
        """暫停錄製的異步方法"""
        if executor.automation:
            executor.automation.pause_recording()
    
    def pause_recording():
        """暫停錄製"""
        executor.run_task(pause_recording_async())
    
    async def resume_recording_async():
        """繼續錄製的異步方法"""
        if executor.automation:
            executor.automation.resume_recording()
    
    def resume_recording():
        """繼續錄製"""
        executor.run_task(resume_recording_async())
    
    async def stop_recording_async():
        """停止錄製的異步方法"""
        if not executor.automation:
            return
        
        try:
            # 獲取錄製的操作
            actions = await executor.automation.stop_recording()
            
            # 將操作添加到腳本中
            for action in actions:
                app.root.after(0, lambda a=action: app.append_script(a))
            
            # 嘗試關閉瀏覽器
            try:
                await executor.automation.close_browser()
            except Exception as e:
                print(f"關閉瀏覽器時出錯 (忽略): {e}")
            
            # 清除自動化實例
            executor.automation = None
            app.status_var.set("錄製已停止")
        except Exception as e:
            app.status_var.set(f"停止錄製時出錯: {e}")
    
    def stop_recording():
        """停止錄製"""
        app.status_var.set("正在停止錄製...")
        executor.run_task(stop_recording_async())
    
    # 替換執行腳本的方法
    async def execute_script_async(script_content):
        """異步執行腳本"""
        if not script_content.strip():
            app.status_var.set("腳本為空，無法執行")
            return
        
        try:
            # 關閉可能存在的瀏覽器實例
            if executor.automation:
                try:
                    await executor.automation.close_browser()
                except Exception:
                    pass
            
            # 創建新的自動化實例
            executor.automation = BrowserAutomation(
                callback=lambda progress, msg: app.root.after(0, lambda: app.status_var.set(msg))
            )
            
            # 執行腳本
            await executor.automation.execute_script(script_content)
            
            # 執行完成
            app.root.after(0, lambda: app.status_var.set("腳本執行完成"))
        except Exception as e:
            app.root.after(0, lambda: app.status_var.set(f"執行錯誤: {e}"))
        finally:
            executor.automation = None
            app.root.after(0, app.enable_after_execution)
    
    def execute_script(script_content):
        """執行腳本的包裝方法"""
        app.status_var.set("正在執行腳本...")
        executor.run_task(execute_script_async(script_content))
    
    # 替換原始方法
    app.execute_script = execute_script
    app.start_recording = start_recording
    app.pause_recording = pause_recording
    app.resume_recording = resume_recording
    app.stop_recording = stop_recording
    
    # 程序退出時清理
    def on_closing():
        """程序關閉時的清理"""
        async def close_browser():
            if executor.automation:
                try:
                    await executor.automation.close_browser()
                except Exception:
                    pass
        
        # 嘗試關閉瀏覽器
        future = executor.run_task(close_browser())
        if future:
            try:
                future.result(timeout=1)
            except (asyncio.TimeoutError, Exception):
                pass
        
        # 停止執行器
        executor.stop()
        
        # 關閉窗口
        root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    
    # 啟動GUI主循環
    root.mainloop()

if __name__ == "__main__":
    main()
